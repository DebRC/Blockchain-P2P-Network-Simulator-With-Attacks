import sys

sys.path.append("../helper")
from helper.utils import *
from models.event import Event
from models.transaction import Transaction
from models.block import Block
import json
import random
import networkx as nx

script_dir = os.path.dirname(os.path.abspath(__file__))
params_path = os.path.join(script_dir, "../helper", "params.json")

## SAVE LAST BLOCK ID IN CHAIN
## WHOSE MINING FINISH TIME IS THE LEAST


class Node:
    def __init__(
        self,
        nodeID,
        genesisBlock,
        mineTime,
        lowSpeed=False,
        lowCPU=False,
    ):
        self.nodeID = nodeID
        self.lowSpeed = lowSpeed
        self.lowCPU = lowCPU
        self.mineTime = mineTime
        self.lastBlockID = genesisBlock.blockID
        self.blockCreated = 0

        self.neighbors = set()
        self.blockchain = dict()
        self.blockTime = dict()
        self.blockReceived = set()

        self.spuriousBlocks = set()
        self.receivedTXN = set()
        self.g = nx.DiGraph()

        self.addGenesisBlock(genesisBlock)
        # self.addFirstCoinbaseTXN(genesisBlock)
        # self.mineBlock(0)

    def addGenesisBlock(self, genesisBlock):
        """
        Adds the Genesis Block
        """
        self.blockchain[genesisBlock.blockID] = genesisBlock
        self.blockReceived.add(genesisBlock)
        self.blockTime[genesisBlock.blockID] = 0

    def isBlockValid(self, block: Block):
        """
        Checks if the given block's
        attributes are valid
        """
        try:
            prevBlock: Block = self.blockchain[block.prevBlockID]
        except:
            return False
        for txn in block.txnList:
            if txn.type == 1:
                return True
            if (
                block.balance[txn.receiverPeerID] - txn.val
                != prevBlock.balance[txn.receiverPeerID]
            ):
                return False
            if (
                block.balance[txn.senderPeerID] + txn.val
                != prevBlock.balance[txn.senderPeerID]
            ):
                return False
            if prevBlock.balance[txn.senderPeerID] - txn.val < 0:
                return False
        return True

    def getAllIncludedTxn(self):
        """
        Returns all the included transaction upto the last block added in chain
        """
        block: Block = self.blockchain[self.lastBlockID]
        txnIncluded = set()
        while block.prevBlockID != 0:
            txnIncluded = txnIncluded.union(block.txnList)
            block = self.blockchain[block.prevBlockID]
        # print("THIS IS ALREADY INCLUDED:",len(txnIncluded))
        return txnIncluded

    def eventHandler(self, event):
        if event.type == 0:
            self.generateTXN(event)
        elif event.type == 1:
            self.receiveTXN(event)
        elif event.type == 2:
            self.mineBlock(event)
        elif event.type == 3:
            self.finishMine(event)
        elif event.type == 4:
            self.receiveBlock(event)
        else:
            raise ValueError(f"Event Type not Valid")

    def generateTXN(self, event: Event):
        """
        Generates a Transaction and propagates to all it's peers
        """
        # Get the last balance of this node
        selfBalance = self.blockchain[self.lastBlockID].balance[self.nodeID]
        # Check if the balance satisfying the least condition
        if selfBalance < 0:
            return
        # Randomly generate a txn value
        event.txn.val = randomGenerator.uniform(0, selfBalance)
        # If the txn val satisifes g
        if selfBalance > event.txn.val:
            # Add it to received txn
            self.receivedTXN.add(event.txn)
            # Propagate the txn to all it's peers
            for peer in self.neighbors:
                latency = calculateLatency(senderPeer=self, receiverPeer=peer, m=1)
                pushToEventQueue(
                    Event(
                        time=event.time + latency,
                        type=1,
                        txn=event.txn,
                        senderPeer=self,
                        receiverPeer=peer,
                    )
                )

    def receiveTXN(self, event: Event):
        """
        Receive Transaction Generated by other Peers
        and Propagates to all it's peers
        """
        # Check if the transaction is already received
        if event.txn not in self.receivedTXN:
            # Add it to the received TXN
            self.receivedTXN.add(event.txn)
            # Propagate the transaction to it's peers
            for peer in self.neighbors:
                # Calculate the latency
                latency = calculateLatency(senderPeer=self, receiverPeer=peer, m=1)
                # Push the transaction event to the queue
                pushToEventQueue(
                    Event(
                        time=event.time + latency,
                        type=1,
                        txn=event.txn,
                        senderPeer=self,
                        receiverPeer=peer,
                    )
                )

    def mineBlock(self, event: Event):
        """
        Takes up a subset of transactions
        and mine it in a new block
        """
        #
        # print(self.blockchain.keys())
        t=event.time
        lastBlock: Block = self.blockchain[self.lastBlockID]
        while True:
            # Get the remaining TXN
            remainingTxn = self.receivedTXN.difference(self.getAllIncludedTxn())

            # Find out the invalid TXN
            invalidTxn = set(
                [
                    txn
                    for txn in remainingTxn
                    if txn.val > lastBlock.balance[txn.senderPeerID]
                ]
            )

            # Filter the valid txn only
            validTxn = remainingTxn.difference(invalidTxn)

            # # If there is not valid TXN restart mining
            numOfTxn = len(validTxn)
            #     continue

            # Get the maximum block size
            blockSize = json.load(open(params_path))["block-size"]

            # Randomly choose number of transaction, but ensure
            # it is does not exceed the blocksize-2
            # Why 2? 1 for the block itself and 1 for the mining TXN
            if numOfTxn > 1:
                numOfTxn = min(random.randint(1, len(validTxn)), blockSize - 2)

            # Get transaction upto numOfTxn
            includedTxn = set(list(validTxn)[:numOfTxn])
            # print("NODE "+ str(self.nodeID)+"TXN TO BE ADDED WHILE MINING:",len(includedTxn))

            # Get new tranasaction ID
            txnID = generateTransactionID()

            # Get the mining value
            miningValue = json.load(open(params_path))["mining-fee"]

            # Prepare the mining TXN and add it to included txn list
            miningTxn = Transaction(
                txnID=txnID,
                senderPeerID=-1,
                receiverPeerID=self.nodeID,
                val=miningValue,
                type=1,
            )
            includedTxn.add(miningTxn)

            # Get new block ID
            blockID = generateBlockID()

            # Prepare a block with the transaction chosen
            block = Block(
                blockID=blockID,
                prevBlockID=self.lastBlockID,
                prevLengthOfChain=lastBlock.length,
                txnList=includedTxn,
                miner=self,
                prevBlockBalance=lastBlock.balance,\
            )

            # Check if the block is all valid
            if self.isBlockValid(block):
                break

        # Add the latency for the block propagation to it's peers
        t += randomGenerator.exponential(self.mineTime)
        # Add to the event queue with type = 3
        pushToEventQueue(Event(time=t, type=3, block=block, receiverPeer=self))

    def finishMine(self, event: Event):
        time=event.time
        block=event.block
        if not self.isBlockValid(block):
            return
        if block.blockID in self.blockchain:
            return
        self.blockchain[block.blockID] = block

        if(block.prevBlockID == self.lastBlockID):
            self.lastBlockID = block.blockID
            for peer in self.neighbors:
                latency = calculateLatency(
                    senderPeer=self, receiverPeer=peer, m=block.size
                )
                pushToEventQueue(
                    Event(
                        time=time + latency,
                        type=4,
                        senderPeer=self,
                        receiverPeer=peer,
                        block=block,
                    )
                )

    def receiveBlock(self, event: Event):
        block = event.block
        time = event.time
        if not self.isBlockValid(block):
            return
        if block.blockID in self.blockchain:
            return
        lastBlock: Block = self.blockchain[self.lastBlockID]
        self.blockchain[block.blockID] = block
        if (block.length > lastBlock.length):
            self.lastBlockID = block.blockID
            for peer in self.neighbors:
                latency = calculateLatency(
                    senderPeer=self, receiverPeer=peer, m=block.size
                )
                pushToEventQueue(
                    Event(
                        time=time + latency,
                        type=4,
                        senderPeer=self,
                        receiverPeer=peer,
                        block=block,
                    )
                )
            pushToEventQueue(Event(time=time, type=2, receiverPeer=self))
